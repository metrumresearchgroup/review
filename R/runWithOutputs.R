#' Run an R script and capture the generated outputs
#'
#' @description
#' Executes an R script in a separate R session using `here::here()` as the
#' working directory. Console output is written to
#' `data/outputs/<script-path>.log`, where `<script-path>` is the script's path
#' relative to the project root (without the file extension) with folder levels
#' separated by `--`. File creation, deletion, and modification events are
#' recorded in `data/outputs/<script-path>-outputs.csv`. Each CSV row contains
#' the event type and the affected output path relative to the project root.
#'
#' @param script Path to the R script to execute.
#'
#' @return Invisibly returns `NULL`.
#'
#' @examples
#' \dontrun{
#' runWithOutputs("inst/scripts/report.R")
#' }
#' @export
runWithOutputs <- function(script) {
  wd <- here::here()
  script_abs <- fs::path_abs(script, start = wd)
  if (!fs::file_exists(script_abs)) {
    cli::cli_abort("Script not found: {.file {script}}")
  }

  script_rel <- fs::path_rel(script_abs, start = wd)
  script_rel_no_ext <- fs::path_ext_remove(script_rel)
  script_tag <- paste(fs::path_split(script_rel_no_ext)[[1]], collapse = "--")

  output_dir <- here::here("data", "outputs")
  log_path <- fs::path(output_dir, paste0(script_tag, ".log"))
  csv_path <- fs::path(output_dir, paste0(script_tag, "-outputs.csv"))
  csv_rel <- fs::path_rel(csv_path, start = wd)
  log_rel <- fs::path_rel(log_path, start = wd)
  fs::dir_create(output_dir, recurse = TRUE)

  snapshot <- function(root) {
    paths <- fs::dir_ls(
      path = root,
      recurse = TRUE,
      type = "file",
      regexp = "(/renv/|/data/outputs/)",
      invert = TRUE
    )
    info <- fs::file_info(paths)
    dplyr::tibble(
      path = fs::path_rel(paths, start = root),
      mtime = info$modification_time
    )
  }

  run_id <- cli::cli_process_start(
    "Running in a fresh R session: {.file {script_rel}}"
  )
  pre <- snapshot(wd)

  stdout_tmp <- fs::file_temp(
    pattern = paste0(script_tag, "_console_"),
    ext = ".log"
  )
  on.exit(
    if (fs::file_exists(stdout_tmp)) fs::file_delete(stdout_tmp),
    add = TRUE
  )

  exit_status <- tryCatch(
    {
      callr::rscript(
        script = script_abs,
        wd = wd,
        user_profile = TRUE,
        system_profile = FALSE,
        cmdargs = c("--no-save", "--no-restore"),
        stdout = stdout_tmp,
        stderr = stdout_tmp,
        show = FALSE,
        spinner = TRUE,
        env = c(
          CLI_NUM_COLORS = "0",
          R_CLI_NUM_COLORS = "0",
          NO_COLOR = "1",
          CRAYON_ENABLED = "FALSE",
          CLICOLOR_FORCE = "0"
        )
      )
      0L
    },
    error = function(e) 1L
  )

  if (!fs::file_exists(stdout_tmp)) {
    fs::file_create(stdout_tmp)
  }
  fs::file_copy(stdout_tmp, log_path, overwrite = TRUE)

  if (exit_status == 0L) {
    cli::cli_process_done(run_id)
  } else {
    cli::cli_process_failed(run_id)
    cli::cli_alert_danger(
      "Script failed. See log for details: {.file {log_rel}}"
    )
    stop("Script failed", call. = FALSE)
  }

  post <- snapshot(wd)

  changes <- dplyr::full_join(
    pre,
    post,
    by = "path",
    suffix = c("_pre", "_post")
  )

  with_events <- changes %>%
    dplyr::mutate(
      event = dplyr::case_when(
        is.na(mtime_pre) & !is.na(mtime_post) ~ "created",
        !is.na(mtime_pre) & is.na(mtime_post) ~ "deleted",
        !is.na(mtime_pre) & !is.na(mtime_post) & mtime_pre != mtime_post ~
          "modified",
        TRUE ~ NA_character_
      )
    )

  files_df <- with_events %>%
    dplyr::filter(!is.na(event)) %>%
    dplyr::transmute(script = script_rel, event, output = path)

  readr::write_csv(files_df, csv_path)
  cli::cli_alert_success("Outputs written: {.file {csv_rel}}")

  invisible(NULL)
}

#' Read outputs generated by `runWithOutputs()`
#'
#' @description
#' Aggregates the per-script CSV files generated by `runWithOutputs()` into a
#' single tibble. Each row records the event type (`created`, `deleted`,
#' `modified`) and the relative path of an affected output file, grouped by the
#' script that produced the change.
#'
#' @param dir Directory that contains the CSV files written by
#'   `runWithOutputs()`.
#'
#' @return A tibble combining the CSV contents. Returns an empty tibble when no
#'   CSV files are present.
#'
#' @examples
#' \dontrun{
#' readOutputs()
#' }
#' @export
readOutputs <- function(dir = here::here("data", "outputs")) {
  if (!fs::dir_exists(dir)) {
    return(dplyr::tibble())
  }

  files <- fs::dir_ls(dir, type = "file", glob = "*.csv")
  if (length(files) == 0L) {
    return(dplyr::tibble())
  }

  files <- sort(as.character(files))
  names(files) <- fs::path_file(files)

  purrr::map_dfr(
    files,
    ~ readr::read_csv(.x, show_col_types = FALSE),
    .id = "file"
  ) %>%
    dplyr::transmute(file = script, event, output)
}
